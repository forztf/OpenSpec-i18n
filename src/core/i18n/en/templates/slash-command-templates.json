{
  "proposal": {
    "guardrails": "**Guardrails**\n- Favor straightforward, minimal implementations first and add complexity only when it is requested or clearly required.\n- Keep changes tightly scoped to the requested outcome.\n- Refer to `openspec/AGENTS.md` (located inside the `openspec/` directory—run `ls openspec` or `openspec update` if you don't see it) if you need additional OpenSpec conventions or clarifications.\n- Identify any vague or ambiguous details and ask the necessary follow-up questions before editing files.",
    "steps": "**Steps**\n1. Review `openspec/project.md`, run `openspec list` and `openspec list --specs`, and inspect related code or docs (e.g., via `rg`/`ls`) to ground the proposal in current behaviour; note any gaps that require clarification.\n2. Choose a unique verb-led `change-id` and scaffold `proposal.md`, `tasks.md`, and `design.md` (when needed) under `openspec/changes/<id>/`.\n3. Map the change into concrete capabilities or requirements, breaking multi-scope efforts into distinct spec deltas with clear relationships and sequencing.\n4. Capture architectural reasoning in `design.md` when the solution spans multiple systems, introduces new patterns, or demands trade-off discussion before committing to specs.\n5. Draft spec deltas in `changes/<id>/specs/<capability>/spec.md` (one folder per capability) using `## ADDED|MODIFIED|REMOVED Requirements` with at least one `#### Scenario:` per requirement and cross-reference related capabilities when relevant.\n6. Draft `tasks.md` as an ordered list of small, verifiable work items that deliver user-visible progress, include validation (tests, tooling), and highlight dependencies or parallelizable work.\n7. Validate with `openspec validate <id> --strict` and resolve every issue before sharing the proposal.",
    "references": "**Reference**\n- Use `openspec show <id> --json --deltas-only` or `openspec show <spec> --type spec` to inspect details when validation fails.\n- Search existing requirements with `rg -n \"Requirement:|Scenario:\" openspec/specs` before writing new ones.\n- Explore the codebase with `rg <keyword>`, `ls`, or direct file reads so proposals align with current implementation realities."
  },
  "apply": {
    "guardrails": "**Guardrails**\n- Favor straightforward, minimal implementations first and add complexity only when it is requested or clearly required.\n- Keep changes tightly scoped to the requested outcome.\n- Refer to `openspec/AGENTS.md` (located inside the `openspec/` directory—run `ls openspec` or `openspec update` if you don't see it) if you need additional OpenSpec conventions or clarifications.",
    "steps": "**Steps**\nTrack these steps as TODOs and complete them one by one.\n1. Read `changes/<id>/proposal.md`, `design.md` (if present), and `tasks.md` to confirm scope and acceptance criteria.\n2. Work through tasks sequentially, keeping edits minimal and focused on the requested change.\n3. Confirm completion before updating statuses—make sure every item in `tasks.md` is finished.\n4. Update the checklist after all work is done so each task is marked `- [x]` and reflects reality.\n5. Reference `openspec list` or `openspec show <item>` when additional context is required.",
    "references": "**Reference**\n- Use `openspec show <id> --json --deltas-only` if you need additional context from the proposal while implementing."
  },
  "archive": {
    "guardrails": "**Guardrails**\n- Favor straightforward, minimal implementations first and add complexity only when it is requested or clearly required.\n- Keep changes tightly scoped to the requested outcome.\n- Refer to `openspec/AGENTS.md` (located inside the `openspec/` directory—run `ls openspec` or `openspec update` if you don't see it) if you need additional OpenSpec conventions or clarifications.",
    "steps": "**Steps**\n1. Determine the change ID to archive:\n   - If this prompt already includes a specific change ID (for example inside a `<ChangeId>` block populated by slash-command arguments), use that value after trimming whitespace.\n   - If the conversation references a change loosely (for example by title or summary), run `openspec list` to surface likely IDs, share the relevant candidates, and confirm which one the user intends.\n   - Otherwise, review the conversation, run `openspec list`, and ask the user which change to archive; wait for a confirmed change ID before proceeding.\n   - If you still cannot identify a single change ID, stop and tell the user you cannot archive anything yet.\n2. Validate the change ID by running `openspec list` (or `openspec show <id>`) and stop if the change is missing, already archived, or otherwise not ready to archive.\n3. Run `openspec archive <id> --yes` so the CLI moves the change and applies spec updates without prompts (use `--skip-specs` only for tooling-only work).\n4. Review the command output to confirm the target specs were updated and the change landed in `changes/archive/`.\n5. Validate with `openspec validate --strict` and inspect with `openspec show <id>` if anything looks off.",
    "references": "**Reference**\n- Use `openspec list` to confirm change IDs before archiving.\n- Inspect refreshed specs with `openspec list --specs` and address any validation issues before handing off."
  }
}