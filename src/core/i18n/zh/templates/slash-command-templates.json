{
  "proposal": {
    "guardrails": "**防护措施**\n- 首先采用直接、最小的实现，只有在明确需要时才添加复杂性。\n- 保持变更范围紧密围绕请求的结果。\n- 如果需要额外的 OpenSpec 约定或澄清，请参考 `openspec/AGENTS.md`（位于 `openspec/` 目录中——如果看不到，请运行 `ls openspec` 或 `openspec update`）。\n- 识别任何模糊或不明确的细节，并在编辑文件之前询问必要的后续问题。",
    "steps": "**步骤**\n1. 查看 `openspec/project.md`，运行 `openspec list` 和 `openspec list --specs`，并检查相关代码或文档（例如通过 `rg`/`ls`）以将提案基于当前行为；注意需要澄清的任何差距。\n2. 选择一个唯一的动词开头的 `change-id`，并在 `openspec/changes/<id>/` 下搭建 `proposal.md`、`tasks.md` 和 `design.md`（需要时）。\n3. 将变更映射到具体的功能或需求，将多范围的工作分解为具有明确关系和顺序的不同规范增量。\n4. 当解决方案跨越多个系统、引入新模式或在提交规范之前需要权衡讨论时，在 `design.md` 中记录架构推理。\n5. 在 `changes/<id>/specs/<capability>/spec.md`（每个功能一个文件夹）中起草规范增量，使用 `## ADDED|MODIFIED|REMOVED Requirements`，每个需求至少包含一个 `#### Scenario:`，并在相关时交叉引用相关功能。\n6. 将 `tasks.md` 起草为有序的小型可验证工作项列表，交付用户可见的进度，包括验证（测试、工具），并突出依赖关系或可并行的工作。\n7. 使用 `openspec validate <id> --strict` 进行验证，并在分享提案之前解决每个问题。",
    "references": "**参考**\n- 当验证失败时，使用 `openspec show <id> --json --deltas-only` 或 `openspec show <spec> --type spec` 检查详细信息。\n- 在编写新需求之前，使用 `rg -n \"Requirement:|Scenario:\" openspec/specs` 搜索现有需求。\n- 使用 `rg <keyword>`、`ls` 或直接文件读取探索代码库，使提案与当前实现现实保持一致。"
  },
  "apply": {
    "guardrails": "**防护措施**\n- 首先采用直接、最小的实现，只有在明确需要时才添加复杂性。\n- 保持变更范围紧密围绕请求的结果。\n- 如果需要额外的 OpenSpec 约定或澄清，请参考 `openspec/AGENTS.md`（位于 `openspec/` 目录中——如果看不到，请运行 `ls openspec` 或 `openspec update`）。",
    "steps": "**步骤**\n按顺序跟踪这些步骤并逐一完成。\n1. 阅读 `changes/<id>/proposal.md`、`design.md`（如果存在）和 `tasks.md` 以确认范围和验收标准。\n2. 按顺序处理任务，保持编辑最小化并专注于请求的变更。\n3. 在更新状态之前确认完成——确保 `tasks.md` 中的每个项目都已完成。\n4. 在所有工作完成后更新清单，使每个任务标记为 `- [x]` 并反映实际情况。\n5. 当需要额外上下文时，参考 `openspec list` 或 `openspec show <item>`。",
    "references": "**参考**\n- 如果在实施过程中需要提案的额外上下文，请使用 `openspec show <id> --json --deltas-only`。"
  },
  "archive": {
    "guardrails": "**防护措施**\n- 首先采用直接、最小的实现，只有在明确需要时才添加复杂性。\n- 保持变更范围紧密围绕请求的结果。\n- 如果需要额外的 OpenSpec 约定或澄清，请参考 `openspec/AGENTS.md`（位于 `openspec/` 目录中——如果看不到，请运行 `ls openspec` 或 `openspec update`）。",
    "steps": "**步骤**\n1. 确定要归档的变更 ID：\n   - 如果此提示已经包含特定的变更 ID（例如在由斜杠命令参数填充的 `<ChangeId>` 块中），请在修剪空白后使用该值。\n   - 如果对话松散地引用了变更（例如按标题或摘要），请运行 `openspec list` 以显示可能的 ID，分享相关候选，并确认用户意图。\n   - 否则，请查看对话，运行 `openspec list`，并询问用户要归档哪个变更；等待确认的变更 ID 后再继续。\n   - 如果仍然无法识别单个变更 ID，请停止并告诉用户您还不能归档任何内容。\n2. 通过运行 `openspec list`（或 `openspec show <id>`）验证变更 ID，如果变更缺失、已归档或未准备好归档，则停止。\n3. 运行 `openspec archive <id> --yes`，使 CLI 移动变更并应用规范更新而无需提示（仅对仅工具工作使用 `--skip-specs`）。\n4. 查看命令输出以确认目标规范已更新，变更已移至 `changes/archive/`。\n5. 使用 `openspec validate --strict` 进行验证，如果出现任何问题，请使用 `openspec show <id>` 进行检查。",
    "references": "**参考**\n- 在归档之前使用 `openspec list` 确认变更 ID。\n- 使用 `openspec list --specs` 检查刷新的规范，并在移交之前解决任何验证问题。"
  }
}